/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myst.CSV;
import org.xtext.example.mydsl.myst.Calcul;
import org.xtext.example.mydsl.myst.CrossValidation;
import org.xtext.example.mydsl.myst.MystPackage;
import org.xtext.example.mydsl.myst.Parse;
import org.xtext.example.mydsl.myst.Program;
import org.xtext.example.mydsl.myst.Strategy;
import org.xtext.example.mydsl.myst.TrainingTest;
import org.xtext.example.mydsl.services.MystGrammarAccess;

@SuppressWarnings("all")
public class MystSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MystGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MystPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MystPackage.CSV:
				sequence_CSV(context, (CSV) semanticObject); 
				return; 
			case MystPackage.CALCUL:
				sequence_Calcul(context, (Calcul) semanticObject); 
				return; 
			case MystPackage.CROSS_VALIDATION:
				sequence_CrossValidation(context, (CrossValidation) semanticObject); 
				return; 
			case MystPackage.PARSE:
				sequence_Parse(context, (Parse) semanticObject); 
				return; 
			case MystPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case MystPackage.STRATEGY:
				sequence_Strategy(context, (Strategy) semanticObject); 
				return; 
			case MystPackage.TRAINING_TEST:
				sequence_TrainingTest(context, (TrainingTest) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CSV returns CSV
	 *
	 * Constraint:
	 *     cvsfile=STRING
	 */
	protected void sequence_CSV(ISerializationContext context, CSV semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.CSV__CVSFILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.CSV__CVSFILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCSVAccess().getCvsfileSTRINGTerminalRuleCall_1_0(), semanticObject.getCvsfile());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Calcul returns Calcul
	 *
	 * Constraint:
	 *     (strategy=Strategy algorithm=Algorithm)
	 */
	protected void sequence_Calcul(ISerializationContext context, Calcul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.CALCUL__STRATEGY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.CALCUL__STRATEGY));
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.CALCUL__ALGORITHM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.CALCUL__ALGORITHM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCalculAccess().getStrategyStrategyParserRuleCall_0_0(), semanticObject.getStrategy());
		feeder.accept(grammarAccess.getCalculAccess().getAlgorithmAlgorithmEnumRuleCall_2_0(), semanticObject.getAlgorithm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CrossValidation returns CrossValidation
	 *
	 * Constraint:
	 *     motcle='crossValidation'
	 */
	protected void sequence_CrossValidation(ISerializationContext context, CrossValidation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.CROSS_VALIDATION__MOTCLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.CROSS_VALIDATION__MOTCLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCrossValidationAccess().getMotcleCrossValidationKeyword_0(), semanticObject.getMotcle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parse returns Parse
	 *
	 * Constraint:
	 *     variableCible=STRING
	 */
	protected void sequence_Parse(ISerializationContext context, Parse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.PARSE__VARIABLE_CIBLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.PARSE__VARIABLE_CIBLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParseAccess().getVariableCibleSTRINGTerminalRuleCall_1_0(), semanticObject.getVariableCible());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (csv=CSV parse=Parse calcul=Calcul metric=Metric)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.PROGRAM__CSV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.PROGRAM__CSV));
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.PROGRAM__PARSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.PROGRAM__PARSE));
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.PROGRAM__CALCUL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.PROGRAM__CALCUL));
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.PROGRAM__METRIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.PROGRAM__METRIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramAccess().getCsvCSVParserRuleCall_0_0(), semanticObject.getCsv());
		feeder.accept(grammarAccess.getProgramAccess().getParseParseParserRuleCall_1_0(), semanticObject.getParse());
		feeder.accept(grammarAccess.getProgramAccess().getCalculCalculParserRuleCall_2_0(), semanticObject.getCalcul());
		feeder.accept(grammarAccess.getProgramAccess().getMetricMetricEnumRuleCall_3_0(), semanticObject.getMetric());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Strategy returns Strategy
	 *
	 * Constraint:
	 *     (trainingTest=TrainingTest | crossValidation=CrossValidation)
	 */
	protected void sequence_Strategy(ISerializationContext context, Strategy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TrainingTest returns TrainingTest
	 *
	 * Constraint:
	 *     testRate=POURCENTAGE_TEST
	 */
	protected void sequence_TrainingTest(ISerializationContext context, TrainingTest semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MystPackage.Literals.TRAINING_TEST__TEST_RATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MystPackage.Literals.TRAINING_TEST__TEST_RATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrainingTestAccess().getTestRatePOURCENTAGE_TESTTerminalRuleCall_2_0(), semanticObject.getTestRate());
		feeder.finish();
	}
	
	
}
